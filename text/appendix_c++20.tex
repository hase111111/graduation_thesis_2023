%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% 付録.tex
%% LaTeX-2e 専用
%% 
%% 
%%        設計工学研究室　学位論文テンプレート
%%
%%                      作成日時    2010年 12月 17日
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{C++20への移行}\label{chapter:付録A}
\section{C++20の新機能}
C++にはコンパイラの標準規格として，C++98，C++03，C++11などが存在する．
その中でもC++11以降は約3年に一度のペースで新しい規格が策定されている．
先行研究のプログラムでは，C++17を使用していたが，本研究ではC++20を使用するように変更を行った．
C++20では，C++17からの変更点として，以下のようなものがある．
\begin{itemize}
  \item constexpr関数の制限緩和
  \item conceptの導入
\end{itemize}
これらの機能を使用することで，プログラムの最適化を行うことができる上，可読性を向上されることができる．
以下に各機能の詳細を記述する．

\section{constexpr変数・関数}
constexpr関数はコンパイル時に評価される関数であり，
C言語におけるマクロ関数のような処理を実現するために使用される．
たとえば，以下のようなプログラムを考える．

\begin{lstlisting}[caption=convert func as macro,label=convert_func_as_macro]
#include <iostream>

// defined as macro
#define CONVERT_TO_RAD(deg) (deg * 3.1415926535f / 180.0f)  

int main()
{
  float deg = 90.0f;
  
  // It will deploy deg * 3.1415926535f / 180.0f.
  std::cout << CONVERT_TO_RAD(deg) << std::endl;
}
\end{lstlisting}

このプログラムでは，マクロ関数を使用して，度数法で表された角度をラジアンに変換している．
プログラムを記述する際にはラジアンで角度を表現すると可読性が低くなるため，
度数法で記述することによる利点は大きいが，実際の処理ではラジアンで角度を表現する必要があるので，
このようなマクロが実際に使用されることは多いだろう．

しかし，マクロにはいくつかの問題点がある．
まず1つとして，マクロは常にグローバルスコープで定義されることである．
通常C++の開発においては，クラスや名前空間を使用して，変数や関数をスコープを限定して定義することが多い．
スコープを限定することは，変数や関数の名前が衝突することを防ぐことができるため，
大規模な開発や複数のライブラリを使用する場合には必須である．
しかし，マクロは名前空間内に定義したとしてもグローバルスコープに展開されるため，
名前の衝突を防ぐことができないのである．

もう1つは，マクロは型の確認を行わないことである．
C++はpythonやjava scriptなどの動的型付け言語とは異なり静的型付け言語である．
そのため，コンパイル時に型の不一致や意図しないキャストを警告として出力することができ，
ランタイムエラーを防ぐことができる利点がある．
しかし，マクロはコンパイル時に文字を張り付けるだけであるため，型の確認を行わない．
そのため例えば上記のマクロ関数において，引数をint型やdouble型，果てはその他のクラスなどに変更しても，
float型との掛け算演算子が定義されていればコンパイルは通ってしまう．
先行研究のプログラムではマクロ関数を使用している箇所が多く存在したため，
実際に浮動小数点型のfloat型とdouble型が混在している箇所が存在した．

これをconstexpr関数を使用することで，以下のように書き換えることができる．

\begin{lstlisting}[caption=convert func as constexpr,label=convert_func_as_constexpr]
#include <iostream>

// defined as constexpr function
constexpr float ConvertToRad(float deg)
{
  return deg * 3.1415926535f / 180.0f;
}

int main()
{
  // declared as constexpr variable
  constexpr float deg = 90.0f;
  
  // It will deploy 1.57079632675f.
  std::cout << ConvertToRad(deg) << std::endl;
}
\end{lstlisting}

このようにconstexpr関数を使用することで，マクロ関数のようにコンパイル時に評価される関数を定義することができる．
また，constexpr関数はコンパイル時に評価が行われるため，コンパイル時に型の確認を行うことができる．
加えて，constexpr関数はスコープを限定することができるため，名前の衝突を防ぐことができる．
以上のようにマクロの持つ問題点を解決することができるが，constexpr関数の本当の利点はコンパイル時に処理が実行されることである．
\ref{convert_func_as_constexpr}の14，15行目にあるように，引数を含めてコンパイル時に評価が可能であれば，
コンパイル時に関数が実行される．そのため，関数の呼び出しによるオーバーヘッドを削減することができる．

